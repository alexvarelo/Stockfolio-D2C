/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * Stockfolio Financial Data API
 * A comprehensive financial data API powered by yfinance
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EquityScreenResponse,
  ErrorResponse,
  HTTPValidationError,
  PredefinedScreener,
  ScreenEquitiesApiV1ScreenPostBody,
  ScreenEquitiesApiV1ScreenPostParams,
  ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams,
  SearchInstrumentsApiV1SearchGetParams,
  SearchResponse,
  SearchResult
} from '../financialDataApi.schemas';

import { useSendRequest } from '.././orvalSendRequest';




/**
 * Screen for stocks and other financial instruments based on complex filtering criteria.
    
    ## Supported Operators:
    - **eq**: equals
    - **ne**: not equals
    - **gt**: greater than
    - **lt**: less than
    - **gte**: greater than or equal to
    - **lte**: less than or equal to
    - **contains**: string contains
    - **is-in**: value is in a list
    - **starts-with**: string starts with
    - **ends-with**: string ends with
    - **and**: logical AND (combine multiple conditions)
    - **or**: logical OR (combine multiple conditions)
    
    ## Common Filter Fields:
    
    ### Region:
    ar, at, au, be, br, ca, ch, cl, cn, co, cz, de, dk, ee, eg, es, fi, fr, gb, gr, hk, hu, id, ie, il, in, is, it, jp, kr, kw, lk, lt, lv, mx, my, nl, no, nz, pe, ph, pk, pl, pt, qa, ro, ru, sa, se, sg, sr, sw, th, tr, tw, us, ve, vn, za
    
    ### Exchange (by region):
    - **US**: ASE, BTS, CXI, NCM, NGM, NMS, NYQ, OEM, OQB, OQX, PCX, PNK, YHD
    - **CA**: CNQ, NEO, TOR, VAN
    - **GB**: AQS, IOB, LSE
    - **DE**: BER, DUS, FRA, GER, HAM, MUN, STU
    - **JP**: FKA, JPX, SAP
    - **CN**: SHH, SHZ
    - **HK**: HKG
    - **AU**: ASX
    - **IN**: BSE, NSI
    - **KR**: KOE, KSC
    - **TW**: TAI, TWO
    - And many more...
    
    ### Sector:
    - Basic Materials
    - Communication Services
    - Consumer Cyclical
    - Consumer Defensive
    - Energy
    - Financial Services
    - Healthcare
    - Industrials
    - Real Estate
    - Technology
    - Utilities
    
    ### Industry (examples by sector):
    - **Basic Materials**: Agricultural Inputs, Aluminum, Chemicals, Copper, Gold, Steel
    - **Technology**: Software Application, Semiconductors, Computer Hardware, Consumer Electronics
    - **Healthcare**: Biotechnology, Drug Manufacturers, Medical Devices, Pharmaceutical Retailers
    - **Financial Services**: Banks Regional, Asset Management, Insurance, Capital Markets
    - **Energy**: Oil Gas E P, Oil Gas Refining Marketing, Solar
    - And many more...
    
    ### Financial Metrics:
    - **epsgrowth.lasttwelvemonths**: EPS growth (trailing 12 months)
    - **intradaymarketcap**: Market capitalization
    - **peratio.lasttwelvemonths**: P/E ratio (TTM)
    - **pricebookratio.quarterly**: Price-to-book ratio
    - **returnonequity.lasttwelvemonths**: ROE (TTM)
    - **totalrevenues.lasttwelvemonths**: Total revenues (TTM)
    - **avgdailyvol3m**: Average daily volume (3 months)
    - **beta**: Stock beta
    
    ## Example Query:
    ```json
    {
      "operator": "and",
      "conditions": [
        {"operator": "is-in", "field": "exchange", "value": ["NMS", "NYQ"]},
        {"operator": "eq", "field": "sector", "value": "Technology"},
        {"operator": "lt", "field": "epsgrowth.lasttwelvemonths", "value": 15},
        {"operator": "gt", "field": "intradaymarketcap", "value": 1000000000}
      ]
    }
    ```
 * @summary Screen equities based on complex criteria
 */
export const screenEquitiesApiV1ScreenPost = (
    screenEquitiesApiV1ScreenPostBody: ScreenEquitiesApiV1ScreenPostBody,
    params?: ScreenEquitiesApiV1ScreenPostParams,
 signal?: AbortSignal
) => {
      
      
      return useSendRequest<EquityScreenResponse>(
      {url: `/api/v1/screen`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: screenEquitiesApiV1ScreenPostBody,
        params, signal
    },
      );
    }
  


export const getScreenEquitiesApiV1ScreenPostMutationOptions = <TError = ErrorResponse | HTTPValidationError | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof screenEquitiesApiV1ScreenPost>>, TError,{data: ScreenEquitiesApiV1ScreenPostBody;params?: ScreenEquitiesApiV1ScreenPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof screenEquitiesApiV1ScreenPost>>, TError,{data: ScreenEquitiesApiV1ScreenPostBody;params?: ScreenEquitiesApiV1ScreenPostParams}, TContext> => {

const mutationKey = ['screenEquitiesApiV1ScreenPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof screenEquitiesApiV1ScreenPost>>, {data: ScreenEquitiesApiV1ScreenPostBody;params?: ScreenEquitiesApiV1ScreenPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  screenEquitiesApiV1ScreenPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScreenEquitiesApiV1ScreenPostMutationResult = NonNullable<Awaited<ReturnType<typeof screenEquitiesApiV1ScreenPost>>>
    export type ScreenEquitiesApiV1ScreenPostMutationBody = ScreenEquitiesApiV1ScreenPostBody
    export type ScreenEquitiesApiV1ScreenPostMutationError = ErrorResponse | HTTPValidationError | ErrorResponse

    /**
 * @summary Screen equities based on complex criteria
 */
export const useScreenEquitiesApiV1ScreenPost = <TError = ErrorResponse | HTTPValidationError | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof screenEquitiesApiV1ScreenPost>>, TError,{data: ScreenEquitiesApiV1ScreenPostBody;params?: ScreenEquitiesApiV1ScreenPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof screenEquitiesApiV1ScreenPost>>,
        TError,
        {data: ScreenEquitiesApiV1ScreenPostBody;params?: ScreenEquitiesApiV1ScreenPostParams},
        TContext
      > => {

      const mutationOptions = getScreenEquitiesApiV1ScreenPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Use Yahoo Finance's predefined screeners to find stocks.
    
    Available screeners:
    - **aggressive_small_caps**: Small cap stocks with high growth potential
    - **day_gainers**: Stocks with the highest percentage gains today
    - **day_losers**: Stocks with the highest percentage losses today
    - **growth_technology_stocks**: Technology stocks with strong growth metrics
    - **most_actives**: Most actively traded stocks by volume
    - **most_shorted_stocks**: Stocks with the highest short interest
    - **small_cap_gainers**: Small cap stocks with recent gains
    - **undervalued_growth_stocks**: Growth stocks trading below their intrinsic value
    - **undervalued_large_caps**: Large cap stocks trading below their intrinsic value
    - **conservative_foreign_funds**: Conservative international mutual funds
    - **high_yield_bond**: High yield bond funds
    - **portfolio_anchors**: Stable, dividend-paying stocks
    - **solid_large_growth_funds**: Large cap growth mutual funds
    - **solid_midcap_growth_funds**: Mid cap growth mutual funds
    - **top_mutual_funds**: Top performing mutual funds
 * @summary Use predefined equity screeners
 */
export const screenPredefinedApiV1ScreenPredefinedScreenerNameGet = (
    screenerName: PredefinedScreener,
    params?: ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams,
 signal?: AbortSignal
) => {
      
      
      return useSendRequest<EquityScreenResponse>(
      {url: `/api/v1/screen/predefined/${screenerName}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getScreenPredefinedApiV1ScreenPredefinedScreenerNameGetQueryKey = (screenerName?: PredefinedScreener,
    params?: ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams,) => {
    return [`/api/v1/screen/predefined/${screenerName}`, ...(params ? [params]: [])] as const;
    }

    
export const getScreenPredefinedApiV1ScreenPredefinedScreenerNameGetQueryOptions = <TData = Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(screenerName: PredefinedScreener,
    params?: ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScreenPredefinedApiV1ScreenPredefinedScreenerNameGetQueryKey(screenerName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>> = ({ signal }) => screenPredefinedApiV1ScreenPredefinedScreenerNameGet(screenerName,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(screenerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>>
export type ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetQueryError = ErrorResponse | HTTPValidationError | ErrorResponse


export function useScreenPredefinedApiV1ScreenPredefinedScreenerNameGet<TData = Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 screenerName: PredefinedScreener,
    params: undefined |  ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>,
          TError,
          Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useScreenPredefinedApiV1ScreenPredefinedScreenerNameGet<TData = Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 screenerName: PredefinedScreener,
    params?: ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>,
          TError,
          Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useScreenPredefinedApiV1ScreenPredefinedScreenerNameGet<TData = Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 screenerName: PredefinedScreener,
    params?: ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Use predefined equity screeners
 */

export function useScreenPredefinedApiV1ScreenPredefinedScreenerNameGet<TData = Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 screenerName: PredefinedScreener,
    params?: ScreenPredefinedApiV1ScreenPredefinedScreenerNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof screenPredefinedApiV1ScreenPredefinedScreenerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getScreenPredefinedApiV1ScreenPredefinedScreenerNameGetQueryOptions(screenerName,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Search for stocks, ETFs, and other financial instruments by name, ISIN, or ticker symbol
 * @summary Search for financial instruments
 */
export const searchInstrumentsApiV1SearchGet = (
    params: SearchInstrumentsApiV1SearchGetParams,
 signal?: AbortSignal
) => {
      
      
      return useSendRequest<SearchResponse>(
      {url: `/api/v1/search`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSearchInstrumentsApiV1SearchGetQueryKey = (params?: SearchInstrumentsApiV1SearchGetParams,) => {
    return [`/api/v1/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchInstrumentsApiV1SearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(params: SearchInstrumentsApiV1SearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchInstrumentsApiV1SearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>> = ({ signal }) => searchInstrumentsApiV1SearchGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchInstrumentsApiV1SearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>>
export type SearchInstrumentsApiV1SearchGetQueryError = ErrorResponse | HTTPValidationError | ErrorResponse


export function useSearchInstrumentsApiV1SearchGet<TData = Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 params: SearchInstrumentsApiV1SearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchInstrumentsApiV1SearchGet<TData = Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 params: SearchInstrumentsApiV1SearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchInstrumentsApiV1SearchGet<TData = Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 params: SearchInstrumentsApiV1SearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Search for financial instruments
 */

export function useSearchInstrumentsApiV1SearchGet<TData = Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 params: SearchInstrumentsApiV1SearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchInstrumentsApiV1SearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchInstrumentsApiV1SearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get a list of popular and widely traded stocks
 * @summary Get popular stocks
 */
export const getPopularStocksApiV1SearchPopularGet = (
    
 signal?: AbortSignal
) => {
      
      
      return useSendRequest<SearchResult[]>(
      {url: `/api/v1/search/popular`, method: 'GET', signal
    },
      );
    }
  

export const getGetPopularStocksApiV1SearchPopularGetQueryKey = () => {
    return [`/api/v1/search/popular`] as const;
    }

    
export const getGetPopularStocksApiV1SearchPopularGetQueryOptions = <TData = Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPopularStocksApiV1SearchPopularGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>> = ({ signal }) => getPopularStocksApiV1SearchPopularGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPopularStocksApiV1SearchPopularGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>>
export type GetPopularStocksApiV1SearchPopularGetQueryError = ErrorResponse


export function useGetPopularStocksApiV1SearchPopularGet<TData = Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>,
          TError,
          Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPopularStocksApiV1SearchPopularGet<TData = Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>,
          TError,
          Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPopularStocksApiV1SearchPopularGet<TData = Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get popular stocks
 */

export function useGetPopularStocksApiV1SearchPopularGet<TData = Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPopularStocksApiV1SearchPopularGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPopularStocksApiV1SearchPopularGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Search for a specific financial instrument by ISIN code
 * @summary Search by ISIN
 */
export const searchByIsinApiV1SearchIsinIsinGet = (
    isin: string,
 signal?: AbortSignal
) => {
      
      
      return useSendRequest<SearchResult>(
      {url: `/api/v1/search/isin/${isin}`, method: 'GET', signal
    },
      );
    }
  

export const getSearchByIsinApiV1SearchIsinIsinGetQueryKey = (isin?: string,) => {
    return [`/api/v1/search/isin/${isin}`] as const;
    }

    
export const getSearchByIsinApiV1SearchIsinIsinGetQueryOptions = <TData = Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(isin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchByIsinApiV1SearchIsinIsinGetQueryKey(isin);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>> = ({ signal }) => searchByIsinApiV1SearchIsinIsinGet(isin, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(isin), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchByIsinApiV1SearchIsinIsinGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>>
export type SearchByIsinApiV1SearchIsinIsinGetQueryError = ErrorResponse | HTTPValidationError | ErrorResponse


export function useSearchByIsinApiV1SearchIsinIsinGet<TData = Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 isin: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>,
          TError,
          Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchByIsinApiV1SearchIsinIsinGet<TData = Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 isin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>,
          TError,
          Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchByIsinApiV1SearchIsinIsinGet<TData = Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 isin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Search by ISIN
 */

export function useSearchByIsinApiV1SearchIsinIsinGet<TData = Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError = ErrorResponse | HTTPValidationError | ErrorResponse>(
 isin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByIsinApiV1SearchIsinIsinGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchByIsinApiV1SearchIsinIsinGetQueryOptions(isin,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



